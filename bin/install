#!/usr/bin/env bash
set -euo pipefail

PATH_EXPORT_COMMENT="# Added by agent_hub installer: ensure user-local binaries are on PATH"
PATH_EXPORT_LINE='export PATH="$HOME/.local/bin:$PATH"'
ADD_PATH_MODE="prompt"
UPDATE_METHOD=""

usage() {
  cat <<'USAGE'
Usage: ./bin/install [--add-path | --skip-add-path] <Update Method>

Install launcher scripts for `agent_cli` and `agent_hub` into ~/.local/bin.

Options:
  --add-path       Append PATH export line to the shell rc file without prompting.
  --skip-add-path  Skip PATH update without prompting.

Update Method:
  none  Run tools from this local repository checkout.
  head  Fetch origin default-branch HEAD before every run and execute that commit.
USAGE
}

prompt_yes_no() {
  local prompt="$1"
  local default_yes="${2:-false}"
  local reply=""

  read -r -p "${prompt}" reply || true
  reply="${reply,,}"

  if [[ -z "${reply}" ]]; then
    [[ "${default_yes}" == "true" ]]
    return
  fi

  [[ "${reply}" == "y" || "${reply}" == "yes" ]]
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --add-path)
        if [[ "${ADD_PATH_MODE}" == "skip" ]]; then
          echo "Error: --add-path and --skip-add-path cannot be used together." >&2
          usage >&2
          exit 1
        fi
        ADD_PATH_MODE="force"
        shift
        ;;
      --skip-add-path)
        if [[ "${ADD_PATH_MODE}" == "force" ]]; then
          echo "Error: --add-path and --skip-add-path cannot be used together." >&2
          usage >&2
          exit 1
        fi
        ADD_PATH_MODE="skip"
        shift
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      --*)
        echo "Error: unknown option: $1" >&2
        usage >&2
        exit 1
        ;;
      *)
        if [[ -n "${UPDATE_METHOD}" ]]; then
          echo "Error: exactly one Update Method positional argument is required." >&2
          usage >&2
          exit 1
        fi
        UPDATE_METHOD="$1"
        shift
        ;;
    esac
  done

  if [[ -z "${UPDATE_METHOD}" ]]; then
    echo "Error: missing required Update Method positional argument." >&2
    usage >&2
    exit 1
  fi

  case "${UPDATE_METHOD}" in
    none|head)
      ;;
    *)
      echo "Error: Update Method must be one of: none, head" >&2
      usage >&2
      exit 1
      ;;
  esac
}

normalize_dir_path() {
  local raw="$1"
  if [[ -z "${raw}" ]]; then
    printf '\n'
    return
  fi

  local normalized="${raw}"
  while [[ "${normalized}" != "/" && "${normalized}" == */ ]]; do
    normalized="${normalized%/}"
  done
  printf '%s\n' "${normalized}"
}

path_contains_dir() {
  local candidate
  candidate="$(normalize_dir_path "$1")"
  local entry=""
  local normalized_entry=""
  IFS=':' read -r -a path_entries <<<"${PATH:-}"
  for entry in "${path_entries[@]}"; do
    if [[ -z "${entry}" ]]; then
      continue
    fi
    normalized_entry="$(normalize_dir_path "${entry}")"
    if [[ "${normalized_entry}" == "${candidate}" ]]; then
      return 0
    fi
  done
  return 1
}

detect_supported_shell() {
  local shell_path="${SHELL:-}"
  local shell_name=""
  if [[ -n "${shell_path}" ]]; then
    shell_name="$(basename "${shell_path}")"
  fi

  case "${shell_name}" in
    sh|bash|zsh)
      printf '%s\n' "${shell_name}"
      ;;
    *)
      return 1
      ;;
  esac
}

shell_rc_file() {
  local shell_name="$1"
  case "${shell_name}" in
    sh)
      printf '%s\n' "${HOME}/.profile"
      ;;
    bash)
      printf '%s\n' "${HOME}/.bashrc"
      ;;
    zsh)
      printf '%s\n' "${HOME}/.zshrc"
      ;;
    *)
      return 1
      ;;
  esac
}

append_path_line_to_rc() {
  local rc_file="$1"
  local rc_dir=""
  rc_dir="$(dirname "${rc_file}")"
  mkdir -p "${rc_dir}"
  touch "${rc_file}"

  if grep -Fq "${PATH_EXPORT_LINE}" "${rc_file}"; then
    return
  fi

  {
    printf '\n%s\n' "${PATH_EXPORT_COMMENT}"
    printf '%s\n' "${PATH_EXPORT_LINE}"
  } >>"${rc_file}"
}

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
INSTALL_DIR="${HOME}/.local/bin"
MANAGED_REPO_ROOT="${XDG_DATA_HOME:-${HOME}/.local/share}/agent_hub/repo"

parse_args "$@"

mkdir -p "${INSTALL_DIR}"

prepare_managed_repo() {
  local managed_repo_parent=""
  managed_repo_parent="$(dirname "${MANAGED_REPO_ROOT}")"
  mkdir -p "${managed_repo_parent}"

  if [[ -e "${MANAGED_REPO_ROOT}" && ! -d "${MANAGED_REPO_ROOT}" ]]; then
    echo "Error: managed repository path exists and is not a directory: ${MANAGED_REPO_ROOT}" >&2
    exit 1
  fi

  if [[ -d "${MANAGED_REPO_ROOT}" ]]; then
    rm -rf "${MANAGED_REPO_ROOT}"
  fi

  git clone --quiet --no-hardlinks "${REPO_ROOT}" "${MANAGED_REPO_ROOT}"

  local source_origin_url=""
  if source_origin_url="$(git -C "${REPO_ROOT}" remote get-url origin 2>/dev/null)"; then
    git -C "${MANAGED_REPO_ROOT}" remote set-url origin "${source_origin_url}"
  fi

  local source_origin_head_ref=""
  if source_origin_head_ref="$(git -C "${REPO_ROOT}" symbolic-ref --quiet --short refs/remotes/origin/HEAD 2>/dev/null)"; then
    git -C "${MANAGED_REPO_ROOT}" symbolic-ref refs/remotes/origin/HEAD "${source_origin_head_ref}"
  fi
}

prepare_managed_repo

MANAGED_REPO_ROOT_ESCAPED=""
UPDATE_METHOD_ESCAPED=""
printf -v MANAGED_REPO_ROOT_ESCAPED "%q" "${MANAGED_REPO_ROOT}"
printf -v UPDATE_METHOD_ESCAPED "%q" "${UPDATE_METHOD}"

install_launcher() {
  local tool_name="$1"
  local tool_name_escaped=""
  local launcher_path="${INSTALL_DIR}/${tool_name}"
  printf -v tool_name_escaped "%q" "${tool_name}"

  cat >"${launcher_path}" <<EOF
#!/usr/bin/env bash
set -euo pipefail

SOURCE_REPO_ROOT=${MANAGED_REPO_ROOT_ESCAPED}
UPDATE_METHOD=${UPDATE_METHOD_ESCAPED}
TOOL_NAME=${tool_name_escaped}

resolve_default_branch() {
  local ref=""
  if ! ref="\$(git -C "\${SOURCE_REPO_ROOT}" symbolic-ref --quiet --short refs/remotes/origin/HEAD)"; then
    echo "Failed to resolve origin/HEAD in \${SOURCE_REPO_ROOT}." >&2
    echo "Set update method to 'none' or fix the git remote default branch." >&2
    exit 1
  fi

  if [[ "\${ref}" != origin/* ]]; then
    echo "Unexpected origin/HEAD format: \${ref}" >&2
    exit 1
  fi
  printf '%s\n' "\${ref#origin/}"
}

worktree_is_clean() {
  local worktree_path="\$1"
  local expected_commit="\$2"

  if [[ ! -d "\${worktree_path}" ]]; then
    return 1
  fi
  if [[ ! -x "\${worktree_path}/bin/\${TOOL_NAME}" ]]; then
    return 1
  fi

  local worktree_commit=""
  if ! worktree_commit="\$(git -C "\${worktree_path}" rev-parse --verify HEAD^{commit} 2>/dev/null)"; then
    return 1
  fi
  if [[ "\${worktree_commit}" != "\${expected_commit}" ]]; then
    return 1
  fi

  if ! git -C "\${worktree_path}" diff --no-ext-diff --quiet --exit-code; then
    return 1
  fi
  if ! git -C "\${worktree_path}" diff --no-ext-diff --cached --quiet --exit-code; then
    return 1
  fi
  if [[ -n "\$(git -C "\${worktree_path}" ls-files --others --exclude-standard)" ]]; then
    return 1
  fi

  return 0
}

resolve_repo_root() {
  if [[ "\${UPDATE_METHOD}" == "none" ]]; then
    printf '%s\n' "\${SOURCE_REPO_ROOT}"
    return
  fi

  local default_branch=""
  default_branch="\$(resolve_default_branch)"
  git -C "\${SOURCE_REPO_ROOT}" fetch --quiet --prune origin "\${default_branch}"

  local target_ref="origin/\${default_branch}"
  local target_commit=""
  target_commit="\$(git -C "\${SOURCE_REPO_ROOT}" rev-parse --verify "\${target_ref}^{commit}")"

  local worktree_root="\${XDG_CACHE_HOME:-\${HOME}/.cache}/agent_hub/head-worktrees"
  mkdir -p "\${worktree_root}"
  local worktree_path="\${worktree_root}/\${target_commit}"

  if ! worktree_is_clean "\${worktree_path}" "\${target_commit}"; then
    if [[ -d "\${worktree_path}" ]]; then
      git -C "\${SOURCE_REPO_ROOT}" worktree remove --force "\${worktree_path}"
    fi
    git -C "\${SOURCE_REPO_ROOT}" worktree add --quiet --detach "\${worktree_path}" "\${target_commit}"
  fi

  printf '%s\n' "\${worktree_path}"
}

main() {
  local repo_root=""
  repo_root="\$(resolve_repo_root)"
  exec "\${repo_root}/bin/\${TOOL_NAME}" "\$@"
}

main "\$@"
EOF
  chmod +x "${launcher_path}"
}

install_launcher "agent_cli"
install_launcher "agent_hub"

ensure_install_dir_on_path() {
  if path_contains_dir "${INSTALL_DIR}"; then
    return
  fi

  case "${ADD_PATH_MODE}" in
    skip)
      echo "PATH update skipped (--skip-add-path): ${INSTALL_DIR} is not currently on PATH."
      return
      ;;
    prompt)
      if [[ ! -t 0 ]]; then
        echo "Not updating PATH automatically because stdin is not interactive." >&2
        echo "Re-run with --add-path or --skip-add-path." >&2
        return
      fi
      if ! prompt_yes_no "${INSTALL_DIR} is not on PATH. Add it to your shell startup file? [y/N] " "false"; then
        echo "PATH update skipped."
        return
      fi
      ;;
    force)
      ;;
    *)
      echo "Error: unsupported add-path mode: ${ADD_PATH_MODE}" >&2
      exit 1
      ;;
  esac

  local shell_name=""
  if ! shell_name="$(detect_supported_shell)"; then
    echo "Unable to determine supported shell from SHELL=${SHELL:-<unset>}." >&2
    echo "Supported shells for PATH updates are: sh, bash, zsh." >&2
    if [[ "${ADD_PATH_MODE}" == "force" ]]; then
      exit 1
    fi
    return
  fi

  local rc_file=""
  rc_file="$(shell_rc_file "${shell_name}")"
  append_path_line_to_rc "${rc_file}"
  echo "Added PATH update to ${rc_file}."
  echo "Start a new shell or run: source ${rc_file}"
}

ensure_install_dir_on_path

echo "Installed launchers:"
echo "  ${INSTALL_DIR}/agent_cli"
echo "  ${INSTALL_DIR}/agent_hub"
echo "Managed repository: ${MANAGED_REPO_ROOT}"
echo "Update Method: ${UPDATE_METHOD}"
